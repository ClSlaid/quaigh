//! IO for test patterns

use std::io::{BufRead, BufReader, Read, Write};

/// Read multiple sequential test patterns from a file
///
/// These files describe input patterns for a design:
/// ```text
///     * This is a comment
///
///     * Input pattern with five input values set to zero
///     1: 00000
///
///     * The index increments at each pattern
///     2: 00000
///
///     * A pattern can describe multiple timesteps
///     3: 01110 00111 01000
///
///     * The index is optional
///     01110 00111 01000
/// ```
pub fn read_patterns<R: Read>(r: R) -> Result<Vec<Vec<Vec<bool>>>, String> {
    let mut ret = Vec::new();
    let mut ind: usize = 1;
    for l in BufReader::new(r).lines() {
        if let Ok(s) = l {
            let t = s.trim();
            if t.is_empty() || t.starts_with('*') {
                continue;
            }
            let sp = t.split(':').collect::<Vec<_>>();
            if sp.len() >= 3 || sp.is_empty() {
                panic!("Expected line of the form INDEX: TIMESTEP_1 TIMESTEP_2 ... TIMESTEP_N");
            }
            if sp.len() == 2 {
                let line_ind: usize = sp[0].trim().parse().unwrap();
                if line_ind != ind {
                    panic!("Index {line_ind} on a line does not match expected {ind}");
                }
            }
            ind += 1;
            let patterns = if sp.len() == 2 {
                sp[1].split_whitespace()
            } else {
                sp[0].split_whitespace()
            };
            let mut seq_ret = Vec::new();
            for p in patterns {
                let mut comb_ret = Vec::new();
                for c in p.chars() {
                    if c == '0' {
                        comb_ret.push(false);
                    } else if c == '1' {
                        comb_ret.push(true);
                    } else {
                        panic!("Unexpected character {c} in a pattern");
                    }
                }
                seq_ret.push(comb_ret);
            }
            ret.push(seq_ret);
        }
    }
    Ok(ret)
}

/// Write multiple sequential test patterns to a file
///
/// These files describe input patterns for a design:
/// ```text
///     * This is a comment
///
///     * Input pattern with five input values set to zero
///     1: 00000
///
///     * The index increments at each pattern
///     2: 00000
///
///     * A pattern can describe multiple timesteps
///     3: 01110 00111 01000
///
///     * The index is optional
///     01110 00111 01000
/// ```
pub fn write_patterns<W: Write>(w: &mut W, patterns: &Vec<Vec<Vec<bool>>>) {
    writeln!(w, "* Test pattern file").unwrap();
    writeln!(w, "* generated by quaigh").unwrap();
    for (i, v) in patterns.iter().enumerate() {
        write!(w, "{}:", i + 1).unwrap();
        for seq_pattern in v {
            write!(w, " ").unwrap();
            for inp_value in seq_pattern {
                write!(w, "{}", if *inp_value { "1" } else { "0" }).unwrap();
            }
        }
        writeln!(w).unwrap();
    }
}

mod test {
    #[test]
    fn test_read_pattern() {
        let example = "  * comment1
*comment2
1: 00000 00000
2: 01010  11111\t11111
3:
00000
*comment 3
5: 00000";
        let patterns = super::read_patterns(example.as_bytes()).unwrap();
        assert_eq!(patterns.len(), 5);
        assert_eq!(
            patterns[0],
            vec![
                vec![false, false, false, false, false],
                vec![false, false, false, false, false]
            ]
        );
        assert_eq!(
            patterns[1],
            vec![
                vec![false, true, false, true, false],
                vec![true, true, true, true, true],
                vec![true, true, true, true, true]
            ]
        );
        assert_eq!(patterns[2], Vec::<Vec<bool>>::new());
        assert_eq!(patterns[3], vec![vec![false, false, false, false, false],]);
        assert_eq!(patterns[4], vec![vec![false, false, false, false, false],]);
    }

    #[test]
    fn test_write_pattern() {
        use super::write_patterns;
        use std::io::BufWriter;

        let example = vec![
            vec![vec![false, true], vec![true, false]],
            vec![vec![true, true]],
        ];
        let mut buf = BufWriter::new(Vec::new());
        write_patterns(&mut buf, &example);
        let s = String::from_utf8(buf.into_inner().unwrap()).unwrap();
        assert_eq!(
            s,
            "* Test pattern file
* generated by quaigh
1: 01 10
2: 11
"
        );
    }
}
